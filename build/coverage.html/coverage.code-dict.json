{"/home/travis/build/npmtest/node-npmtest-react-native-meteor/test.js":"/* istanbul instrument in package npmtest_react_native_meteor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-react-native-meteor/lib.npmtest_react_native_meteor.js":"/* istanbul instrument in package npmtest_react_native_meteor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_react_native_meteor = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_react_native_meteor = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-react-native-meteor/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-react-native-meteor && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_react_native_meteor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_react_native_meteor\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_react_native_meteor.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_react_native_meteor.rollup.js'] =\n            local.assetsDict['/assets.npmtest_react_native_meteor.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_react_native_meteor.__dirname + '/lib.npmtest_react_native_meteor.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-react-native-meteor/node_modules/react-native-meteor/src/Meteor.js":"\nimport { NetInfo, Platform, View } from 'react-native';\n\nimport reactMixin from 'react-mixin';\nimport Trackr from 'trackr';\nimport EJSON from 'ejson';\nimport DDP from '../lib/ddp.js';\nimport Random from '../lib/Random';\n\nimport Data from './Data';\nimport { Collection } from './Collection';\nimport call from './Call';\n\nimport Mixin from './components/Mixin';\nimport MeteorListView from './components/ListView';\nimport MeteorComplexListView from './components/ComplexListView';\nimport createContainer from './components/createContainer';\nimport composeWithTracker from './components/composeWithTracker';\n\nimport FSCollection from './CollectionFS/FSCollection';\nimport FSCollectionImagesPreloader from './CollectionFS/FSCollectionImagesPreloader';\n\nimport ReactiveDict from './ReactiveDict';\n\nimport User from './user/User';\nimport Accounts from './user/Accounts';\n\n\nmodule.exports = {\n  composeWithTracker,\n  Accounts,\n  Tracker: Trackr,\n  EJSON,\n  MeteorListView,\n  MeteorComplexListView,\n  ReactiveDict,\n  Collection,\n  FSCollectionImagesPreloader: Platform.OS == 'android' ? View : FSCollectionImagesPreloader,\n  collection(name, options) { return new Collection(name, options) },\n  FSCollection,\n  createContainer,\n  getData() {\n    return Data;\n  },\n  connectMeteor(reactClass) {\n    return reactMixin.onClass(reactClass, Mixin);\n  },\n  ...User,\n  status() {\n    return {\n      connected: Data.ddp ? Data.ddp.status==\"connected\" : false,\n      status: Data.ddp ? Data.ddp.status : \"disconnected\"\n      //retryCount: 0\n      //retryTime:\n      //reason:\n    }\n  },\n  call: call,\n  disconnect() {\n    if(Data.ddp) {\n      Data.ddp.disconnect();\n    }\n  },\n  _subscriptionsRestart() {\n\n    for(var i in Data.subscriptions) {\n      const sub = Data.subscriptions[i];\n      Data.ddp.unsub(sub.subIdRemember);\n      sub.subIdRemember = Data.ddp.sub(sub.name, sub.params);\n    }\n\n  },\n  waitDdpConnected: Data.waitDdpConnected.bind(Data),\n  reconnect() {\n    Data.ddp && Data.ddp.connect();\n  },\n  connect(endpoint, options) {\n    if(!endpoint) endpoint = Data._endpoint;\n    if(!options) options = Data._options;\n\n    Data._endpoint = endpoint;\n    Data._options = options;\n\n\n    this.ddp = Data.ddp = new DDP({\n      endpoint: endpoint,\n      SocketConstructor: WebSocket,\n      ...options\n    });\n\n    NetInfo.isConnected.addEventListener('change', isConnected=>{\n      if(isConnected && Data.ddp.autoReconnect) {\n        Data.ddp.connect();\n      }\n    });\n\n\n    Data.ddp.on(\"connected\", ()=>{\n\n      Data.notify('change');\n\n      console.info(\"Connected to DDP server.\");\n      this._loadInitialUser().then(() => {\n        this._subscriptionsRestart();\n      });\n    });\n\n    let lastDisconnect = null;\n    Data.ddp.on(\"disconnected\", ()=>{\n\n      Data.notify('change');\n\n      console.info(\"Disconnected from DDP server.\");\n\n      if (!Data.ddp.autoReconnect) return;\n\n      if(!lastDisconnect || new Date() - lastDisconnect > 3000) {\n        Data.ddp.connect();\n      }\n\n      lastDisconnect = new Date();\n\n    });\n\n    Data.ddp.on(\"added\", message => {\n      if(!Data.db[message.collection]) {\n        Data.db.addCollection(message.collection)\n      }\n      Data.db[message.collection].upsert({_id: message.id, ...message.fields});\n    });\n\n    Data.ddp.on(\"ready\", message => {\n      const idsMap = new Map();\n      for(var i in Data.subscriptions) {\n        const sub = Data.subscriptions[i];\n        idsMap.set(sub.subIdRemember, sub.id);\n      }\n      for(var i in message.subs) {\n        const subId = idsMap.get(message.subs[i]);\n        if(subId){\n          const sub = Data.subscriptions[subId];\n          sub.ready = true;\n          sub.readyDeps.changed();\n          sub.readyCallback && sub.readyCallback();\n        }\n      }\n    });\n\n    Data.ddp.on(\"changed\", message => {\n      Data.db[message.collection] && Data.db[message.collection].upsert({_id: message.id, ...message.fields});\n    });\n\n    Data.ddp.on(\"removed\", message => {\n      Data.db[message.collection] && Data.db[message.collection].del(message.id);\n    });\n    Data.ddp.on(\"result\", message => {\n      const call = Data.calls.find(call=>call.id==message.id);\n      if(typeof call.callback == 'function') call.callback(message.error, message.result);\n      Data.calls.splice(Data.calls.findIndex(call=>call.id==message.id), 1);\n    });\n\n    Data.ddp.on(\"nosub\", message => {\n      for(var i in Data.subscriptions) {\n        const sub = Data.subscriptions[i];\n        if(sub.subIdRemember == message.id) {\n          console.warn(\"No subscription existing for\", sub.name);\n        }\n      }\n    });\n\n  },\n  subscribe(name) {\n    var params = Array.prototype.slice.call(arguments, 1);\n    var callbacks = {};\n    if (params.length) {\n      var lastParam = params[params.length - 1];\n      if (typeof lastParam == 'function') {\n        callbacks.onReady = params.pop();\n      } else if (lastParam && (typeof lastParam.onReady == 'function' || typeof lastParam.onError == 'function' || typeof lastParam.onStop == 'function')) {\n        callbacks = params.pop();\n      }\n    }\n\n    // Is there an existing sub with the same name and param, run in an\n    // invalidated Computation? This will happen if we are rerunning an\n    // existing computation.\n    //\n    // For example, consider a rerun of:\n    //\n    //     Tracker.autorun(function () {\n    //       Meteor.subscribe(\"foo\", Session.get(\"foo\"));\n    //       Meteor.subscribe(\"bar\", Session.get(\"bar\"));\n    //     });\n    //\n    // If \"foo\" has changed but \"bar\" has not, we will match the \"bar\"\n    // subcribe to an existing inactive subscription in order to not\n    // unsub and resub the subscription unnecessarily.\n    //\n    // We only look for one such sub; if there are N apparently-identical subs\n    // being invalidated, we will require N matching subscribe calls to keep\n    // them all active.\n\n\n\n    let existing = false;\n    for(var i in Data.subscriptions) {\n      const sub = Data.subscriptions[i];\n      if(sub.inactive && sub.name === name && EJSON.equals(sub.params, params)) existing = sub;\n    }\n\n    let id;\n    if (existing) {\n      id = existing.id;\n      existing.inactive = false;\n\n      if (callbacks.onReady) {\n        // If the sub is not already ready, replace any ready callback with the\n        // one provided now. (It's not really clear what users would expect for\n        // an onReady callback inside an autorun; the semantics we provide is\n        // that at the time the sub first becomes ready, we call the last\n        // onReady callback provided, if any.)\n        if (!existing.ready)\n          existing.readyCallback = callbacks.onReady;\n      }\n      if (callbacks.onStop) {\n        existing.stopCallback = callbacks.onStop;\n      }\n\n    } else {\n\n      // New sub! Generate an id, save it locally, and send message.\n\n      id = Random.id();\n      const subIdRemember = Data.ddp.sub(name, params);\n\n      Data.subscriptions[id] = {\n        id: id,\n        subIdRemember: subIdRemember,\n        name: name,\n        params: EJSON.clone(params),\n        inactive: false,\n        ready: false,\n        readyDeps: new Trackr.Dependency,\n        readyCallback: callbacks.onReady,\n        stopCallback: callbacks.onStop,\n        stop: function() {\n          Data.ddp.unsub(this.subIdRemember);\n          delete Data.subscriptions[this.id];\n          this.ready && this.readyDeps.changed();\n\n          if (callbacks.onStop) {\n            callbacks.onStop();\n          }\n        }\n      };\n\n    }\n\n\n    // return a handle to the application.\n    var handle = {\n      stop: function () {\n        if(Data.subscriptions[id])\n          Data.subscriptions[id].stop();\n      },\n      ready: function () {\n        if (!Data.subscriptions[id]) return false;\n\n        var record = Data.subscriptions[id];\n        record.readyDeps.depend();\n        return record.ready;\n      },\n      subscriptionId: id\n    };\n\n    if (Trackr.active) {\n      // We're in a reactive computation, so we'd like to unsubscribe when the\n      // computation is invalidated... but not if the rerun just re-subscribes\n      // to the same subscription!  When a rerun happens, we use onInvalidate\n      // as a change to mark the subscription \"inactive\" so that it can\n      // be reused from the rerun.  If it isn't reused, it's killed from\n      // an afterFlush.\n      Trackr.onInvalidate(function (c) {\n        if(Data.subscriptions[id]) {\n          Data.subscriptions[id].inactive = true;\n        }\n\n        Trackr.afterFlush(function () {\n          if (Data.subscriptions[id] && Data.subscriptions[id].inactive) {\n            handle.stop();\n          }\n        });\n      });\n    }\n\n    return handle;\n\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-meteor/node_modules/react-native-meteor/lib/ddp.js":"/**\n* DDP.JS 2.1.0\n*/\n\n\nimport EventEmitter from \"wolfy87-eventemitter\";\nimport Queue from \"./queue\";\nimport Socket from \"./socket\";\nimport {contains, uniqueId} from \"./utils\";\n\nconst DDP_VERSION = \"1\";\nconst PUBLIC_EVENTS = [\n    // Subscription messages\n    \"ready\", \"nosub\", \"added\", \"changed\", \"removed\",\n    // Method messages\n    \"result\", \"updated\",\n    // Error messages\n    \"error\"\n];\nconst DEFAULT_RECONNECT_INTERVAL = 10000;\n\nexport default class DDP extends EventEmitter {\n\n    emit () {\n        setTimeout(super.emit.bind(this, ...arguments), 0);\n    }\n\n    constructor (options) {\n\n        super();\n\n        this.status = \"disconnected\";\n\n        // Default `autoConnect` and `autoReconnect` to true\n        this.autoConnect = (options.autoConnect !== false);\n        this.autoReconnect = (options.autoReconnect !== false);\n        this.reconnectInterval = options.reconnectInterval || DEFAULT_RECONNECT_INTERVAL;\n\n        this.messageQueue = new Queue(message => {\n            if (this.status === \"connected\") {\n                this.socket.send(message);\n                return true;\n            } else {\n                return false;\n            }\n        });\n\n        this.socket = new Socket(options.SocketConstructor, options.endpoint);\n\n        this.socket.on(\"open\", () => {\n            // When the socket opens, send the `connect` message\n            // to establish the DDP connection\n            this.socket.send({\n                msg: \"connect\",\n                version: DDP_VERSION,\n                support: [DDP_VERSION]\n            });\n        });\n\n        this.socket.on(\"close\", () => {\n            this.status = \"disconnected\";\n            this.messageQueue.empty();\n            this.emit(\"disconnected\");\n            if (this.autoReconnect) {\n                // Schedule a reconnection\n                setTimeout(\n                    this.socket.open.bind(this.socket),\n                    this.reconnectInterval\n                );\n            }\n        });\n\n        this.socket.on(\"message:in\", message => {\n            if (message.msg === \"connected\") {\n                this.status = \"connected\";\n                this.messageQueue.process();\n                this.emit(\"connected\");\n            } else if (message.msg === \"ping\") {\n                // Reply with a `pong` message to prevent the server from\n                // closing the connection\n                this.socket.send({msg: \"pong\", id: message.id});\n            } else if (contains(PUBLIC_EVENTS, message.msg)) {\n                this.emit(message.msg, message);\n            }\n        });\n\n        if (this.autoConnect) {\n            this.connect();\n        }\n\n    }\n\n    connect () {\n        this.socket.open();\n    }\n\n    disconnect () {\n        /*\n        *   If `disconnect` is called, the caller likely doesn't want the\n        *   the instance to try to auto-reconnect. Therefore we set the\n        *   `autoReconnect` flag to false.\n        */\n        this.autoReconnect = false;\n        this.socket.close();\n    }\n\n    method (name, params) {\n        const id = uniqueId();\n        this.messageQueue.push({\n            msg: \"method\",\n            id: id,\n            method: name,\n            params: params\n        });\n        return id;\n    }\n\n    sub (name, params) {\n        const id = uniqueId();\n        this.messageQueue.push({\n            msg: \"sub\",\n            id: id,\n            name: name,\n            params: params\n        });\n        return id;\n    }\n\n    unsub (id) {\n        this.messageQueue.push({\n            msg: \"unsub\",\n            id: id\n        });\n        return id;\n    }\n\n}","/home/travis/build/npmtest/node-npmtest-react-native-meteor/node_modules/react-native-meteor/lib/queue.js":"export default class Queue {\n\n    /*\n    *   As the name implies, `\u001bconsumer` is the (sole) consumer of the queue.\n    *   It gets called with each element of the queue and its return value\n    *   serves as a ack, determining whether the element is removed or not from\n    *   the queue, allowing then subsequent elements to be processed.\n    */\n\n    constructor (consumer) {\n        this.consumer = consumer;\n        this.queue = [];\n    }\n\n    push (element) {\n        this.queue.push(element);\n        this.process();\n    }\n\n    process () {\n        if (this.queue.length !== 0) {\n            const ack = this.consumer(this.queue[0]);\n            if (ack) {\n                this.queue.shift();\n                this.process();\n            }\n        }\n    }\n\n    empty () {\n        this.queue = [];\n    }\n\n}","/home/travis/build/npmtest/node-npmtest-react-native-meteor/node_modules/react-native-meteor/lib/Random.js":"const UNMISTAKABLE_CHARS = \"23456789ABCDEFGHJKLMNPQRSTWXYZabcdefghijkmnopqrstuvwxyz\";\n\nmodule.exports = {\n  id(count = 17) {\n    let res = \"\";\n    for(let i=0;i<count;i++) {\n      res+=UNMISTAKABLE_CHARS[Math.floor(Math.random() * UNMISTAKABLE_CHARS.length)];\n    }\n    return res;\n  }\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-react-native-meteor/node_modules/react-native-meteor/lib/socket.js":"import EventEmitter from \"wolfy87-eventemitter\";\nimport EJSON from \"ejson\";\n\nexport default class Socket extends EventEmitter {\n\n    constructor (SocketConstructor, endpoint) {\n        super();\n        this.SocketConstructor = SocketConstructor;\n        this.endpoint = endpoint;\n        this.rawSocket = null;\n    }\n\n    send (object) {\n        if (!this.closing) {\n            const message = EJSON.stringify(object);\n            this.rawSocket.send(message);\n            // Emit a copy of the object, as the listener might mutate it.\n            this.emit(\"message:out\", EJSON.parse(message));\n        }\n    }\n\n    open () {\n\n        /*\n        *   Makes `open` a no-op if there's already a `rawSocket`. This avoids\n        *   memory / socket leaks if `open` is called twice (e.g. by a user\n        *   calling `ddp.connect` twice) without properly disposing of the\n        *   socket connection. `rawSocket` gets automatically set to `null` only\n        *   when it goes into a closed or error state. This way `rawSocket` is\n        *   disposed of correctly: the socket connection is closed, and the\n        *   object can be garbage collected.\n        */\n        if (this.rawSocket) {\n            return;\n        }\n        this.closing = false;\n        this.rawSocket = new this.SocketConstructor(this.endpoint);\n\n        /*\n        *   Calls to `onopen` and `onclose` directly trigger the `open` and\n        *   `close` events on the `Socket` instance.\n        */\n        this.rawSocket.onopen = () => this.emit(\"open\");\n        this.rawSocket.onclose = () => {\n            this.rawSocket = null;\n            this.emit(\"close\");\n            this.closing = false;\n        };\n        /*\n        *   Calls to `onmessage` trigger a `message:in` event on the `Socket`\n        *   instance only once the message (first parameter to `onmessage`) has\n        *   been successfully parsed into a javascript object.\n        */\n        this.rawSocket.onmessage = message => {\n            var object;\n            try {\n                object = EJSON.parse(message.data);\n            } catch (ignore) {\n                // Simply ignore the malformed message and return\n                return;\n            }\n            // Outside the try-catch block as it must only catch JSON parsing\n            // errors, not errors that may occur inside a \"message:in\" event\n            // handler\n            this.emit(\"message:in\", object);\n        };\n\n    }\n\n    close () {\n        /*\n        *   Avoid throwing an error if `rawSocket === null`\n        */\n        if (this.rawSocket) {\n            this.closing = true;\n            this.rawSocket.close();\n        }\n    }\n\n}","/home/travis/build/npmtest/node-npmtest-react-native-meteor/node_modules/react-native-meteor/lib/utils.js":"import SHA256 from 'crypto-js/sha256';\nimport _ from \"underscore\";\n\nvar i = 0;\nexport function uniqueId () {\n    return (i++).toString();\n}\n\nexport function contains (array, element) {\n    return array.indexOf(element) !== -1;\n}\n\nexport function hashPassword (password) {\n  return {\n    digest: SHA256(password).toString(),\n    algorithm: \"sha-256\"\n  }\n}\n\n\n//From Meteor core\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar support = {};\n\n// Populate the class2type map\n_.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(name, i) {\n  class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\nfunction type( obj ) {\n  if ( obj == null ) {\n    return obj + \"\";\n  }\n  return typeof obj === \"object\" || typeof obj === \"function\" ?\n    class2type[ toString.call(obj) ] || \"object\" :\n    typeof obj;\n}\n\nfunction isWindow( obj ) {\n  /* jshint eqeqeq: false */\n  return obj != null && obj == obj.window;\n}\n\nexport function isPlainObject ( obj ) {\n  var key;\n\n  // Must be an Object.\n  // Because of IE, we also have to check the presence of the constructor property.\n  // Make sure that DOM nodes and window objects don't pass through, as well\n  if ( !obj || type(obj) !== \"object\" || obj.nodeType || isWindow( obj ) ) {\n    return false;\n  }\n\n  try {\n    // Not own constructor property must be Object\n    if ( obj.constructor &&\n         !hasOwn.call(obj, \"constructor\") &&\n         !hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\") ) {\n      return false;\n    }\n  } catch ( e ) {\n    // IE8,9 Will throw exceptions on certain host objects #9897\n    return false;\n  }\n\n  // Support: IE<9\n  // Handle iteration over inherited properties before own properties.\n  if ( support.ownLast ) {\n    for ( key in obj ) {\n      return hasOwn.call( obj, key );\n    }\n  }\n\n  // Own properties are enumerated firstly, so to speed up,\n  // if last one is own, then all properties are own.\n  for ( key in obj ) {}\n\n  return key === undefined || hasOwn.call( obj, key );\n};\n","/home/travis/build/npmtest/node-npmtest-react-native-meteor/node_modules/react-native-meteor/src/Call.js":"import Data from './Data';\n\nexport default function(eventName) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  if (args.length && typeof args[args.length - 1] === \"function\") {\n    var callback = args.pop();\n  }\n\n\n  const id = Data.ddp.method(eventName, args);\n  Data.calls.push({\n    id: id,\n    callback: callback\n  });\n}","/home/travis/build/npmtest/node-npmtest-react-native-meteor/node_modules/react-native-meteor/src/Collection.js":"import Tracker from 'trackr';\nimport EJSON from 'ejson';\nimport _ from 'underscore';\n\nimport Data from './Data';\nimport Random from '../lib/Random';\nimport call from './Call';\nimport { isPlainObject } from \"../lib/utils.js\";\n\nclass Cursor {\n  constructor(collection, docs) {\n    this._docs = docs || [ ];\n    this._collection = collection;\n  }\n\n  count() { return this._docs.length }\n\n  fetch() { return this._transformedDocs() }\n\n  forEach(callback) { this._transformedDocs().forEach(callback) }\n\n  map(callback) { return this._transformedDocs().map(callback) }\n\n  _transformedDocs() {\n    return this._collection._transform ? this._docs.map(this._collection._transform) : this._docs;\n  }\n}\n\nexport class Collection {\n  constructor(name, options = { }) {\n    if (!Data.db[name]) Data.db.addCollection(name);\n\n    this._collection = Data.db[name];\n    this._cursoredFind = options.cursoredFind;\n    this._name = name;\n    this._transform = wrapTransform(options.transform);\n  }\n\n  find(selector, options) {\n    let result;\n    let docs;\n\n    if(typeof selector == 'string') {\n      if(options) {\n        docs = this._collection.findOne({_id: selector}, options);\n      } else {\n        docs = this._collection.get(selector);\n      }\n\n      if (docs) docs = [ docs ];\n    } else {\n      docs = this._collection.find(selector, options);\n    }\n\n    if (this._cursoredFind) {\n      result = new Cursor(this, docs);\n    } else {\n      if (docs && this._transform) docs = docs.map(this._transform);\n\n      result = docs;\n    }\n\n    return result;\n  }\n\n  findOne(selector, options) {\n    let result = this.find(selector, options);\n\n    if (result) {\n      if (this._cursoredFind) result = result.fetch();\n\n      result = result[0];\n    }\n\n    return result;\n  }\n\n  insert(item, callback = ()=>{}) {\n    let id;\n\n    if('_id' in item) {\n      if(!item._id || typeof item._id != 'string') {\n        return callback(\"Meteor requires document _id fields to be non-empty strings\");\n      }\n      id = item._id;\n    } else {\n      id = item._id = Random.id();\n    }\n\n    if(this._collection.get(id)) return callback({error: 409, reason: `Duplicate key _id with value ${id}`});\n\n    this._collection.upsert(item);\n    Data.waitDdpConnected(()=>{\n      call(`/${this._name}/insert`, item, err => {\n        if(err) {\n          this._collection.del(id);\n          return callback(err);\n        }\n\n        callback(null, id);\n      });\n    });\n\n    return id;\n  }\n\n  update(id, modifier, options={}, callback=()=>{}) {\n    if(typeof options == 'function') {\n      callback = options;\n      options = {};\n    }\n\n    if(!this._collection.get(id)) return callback({\n      error: 409,\n      reason: `Item not found in collection ${this._name} with id ${id}`\n    });\n\n    Data.waitDdpConnected(()=>{\n      call(`/${this._name}/update`, {_id: id}, modifier, err => {\n        if(err) {\n          return callback(err);\n        }\n\n        callback(null, id);\n      });\n    });\n  }\n\n  remove(id, callback = ()=>{}) {\n    const element = this.findOne(id);\n\n    if(element) {\n      this._collection.del(element._id);\n\n      Data.waitDdpConnected(()=>{\n        call(`/${this._name}/remove`, {_id: id}, (err, res) => {\n          if(err) {\n            this._collection.upsert(element);\n            return callback(err);\n          }\n          callback(null, res);\n        });\n      });\n    } else {\n      callback(`No document with _id : ${id}`);\n    }\n  }\n\n  helpers(helpers) {\n    var self = this;\n    let _transform;\n\n    if (this._transform && ! this._helpers)\n      _transform = this._transform;\n\n    if (! this._helpers) {\n      this._helpers = function Document(doc) { return _.extend(this, doc); };\n      this._transform = doc => {\n        if (_transform) {\n          doc = _transform(doc);\n        };\n        return new this._helpers(doc);\n      };\n    }\n\n    _.each(helpers, (helper, key) => {\n      this._helpers.prototype[key] = helper;\n    });\n  }\n}\n\n//From Meteor core\n\n// Wrap a transform function to return objects that have the _id field\n// of the untransformed document. This ensures that subsystems such as\n// the observe-sequence package that call `observe` can keep track of\n// the documents identities.\n//\n// - Require that it returns objects\n// - If the return value has an _id field, verify that it matches the\n//   original _id field\n// - If the return value doesn't have an _id field, add it back.\nfunction wrapTransform(transform) {\n  if (! transform)\n    return null;\n\n  // No need to doubly-wrap transforms.\n  if (transform.__wrappedTransform__)\n    return transform;\n\n  var wrapped = function (doc) {\n    if (!_.has(doc, '_id')) {\n      // XXX do we ever have a transform on the oplog's collection? because that\n      // collection has no _id.\n      throw new Error(\"can only transform documents with _id\");\n    }\n\n    var id = doc._id;\n    // XXX consider making tracker a weak dependency and checking Package.tracker here\n    var transformed = Tracker.nonreactive(function () {\n      return transform(doc);\n    });\n\n    if (!isPlainObject(transformed)) {\n      throw new Error(\"transform must return object\");\n    }\n\n    if (_.has(transformed, '_id')) {\n      if (!EJSON.equals(transformed._id, id)) {\n        throw new Error(\"transformed document can't have different _id\");\n      }\n    } else {\n      transformed._id = id;\n    }\n    return transformed;\n  };\n  wrapped.__wrappedTransform__ = true;\n  return wrapped;\n};","/home/travis/build/npmtest/node-npmtest-react-native-meteor/node_modules/react-native-meteor/src/Data.js":"import ReactNative from 'react-native';\nimport minimongo from 'minimongo-cache';\nimport Trackr from 'trackr';\nimport { InteractionManager } from 'react-native';\nprocess.nextTick = setImmediate;\n\nconst db = new minimongo();\ndb.debug = false;\ndb.batchedUpdates = ReactNative.unstable_batchedUpdates;\n\nfunction runAfterOtherComputations(fn){\n  InteractionManager.runAfterInteractions(() => {\n    Trackr.afterFlush(() => {\n      fn();\n    });\n  });\n}\n\nexport default {\n  _endpoint: null,\n  _options: null,\n  ddp: null,\n  subscriptions: {},\n  db: db,\n  calls: [],\n\n  getUrl() {\n    return this._endpoint.substring(0, this._endpoint.indexOf('/websocket'));\n  },\n\n  waitDdpReady(cb) {\n    if(this.ddp) {\n      cb();\n    } else {\n      runAfterOtherComputations(()=>{\n        this.waitDdpReady(cb);\n      });\n    }\n  },\n\n  _cbs: [],\n  onChange(cb) {\n    this.db.on('change', cb);\n    this.ddp.on('connected', cb);\n    this.ddp.on('disconnected', cb);\n    this.on('loggingIn', cb);\n    this.on('change', cb);\n  },\n  offChange(cb) {\n    this.db.off('change', cb);\n    this.ddp.off('connected', cb);\n    this.ddp.off('disconnected', cb);\n    this.off('loggingIn', cb);\n    this.off('change', cb);\n  },\n  on(eventName, cb) {\n    this._cbs.push({\n      eventName: eventName,\n      callback: cb\n    });\n  },\n  off(eventName, cb) {\n    this._cbs.splice(this._cbs.findIndex(_cb=>_cb.callback == cb && _cb.eventName == eventName), 1);\n  },\n  notify(eventName) {\n    this._cbs.map(cb=>{\n      if(cb.eventName == eventName && typeof cb.callback == 'function') {\n        cb.callback();\n      }\n    });\n  },\n  waitDdpConnected(cb) {\n    if(this.ddp && this.ddp.status == 'connected') {\n      cb();\n    } else if(this.ddp) {\n      this.ddp.once('connected', cb);\n    } else {\n      setTimeout(()=>{ this.waitDdpConnected(cb) }, 10);\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-meteor/node_modules/react-native-meteor/src/ReactiveDict.js":"import EJSON from 'ejson';\n\nimport Data from './Data';\n\nconst stringify = function (value) {\n  if (value === undefined)\n    return 'undefined';\n  return EJSON.stringify(value);\n};\n\nconst parse = function (serialized) {\n  if (serialized === undefined || serialized === 'undefined')\n    return undefined;\n  return EJSON.parse(serialized);\n};\n\nexport default class ReactiveDict {\n  constructor(dictName) {\n    this.keys = {};\n    if (typeof dictName === 'object') {\n      for(var i in dictName) {\n        this.keys[i] = stringify(dictName[i])\n      }\n    }\n  }\n  set(keyOrObject, value) {\n    if ((typeof keyOrObject === 'object') && (value === undefined)) {\n      this._setObject(keyOrObject);\n      return;\n    }\n    // the input isn't an object, so it must be a key\n    // and we resume with the rest of the function\n    const key = keyOrObject;\n\n    value = stringify(value);\n\n    let oldSerializedValue = 'undefined';\n    if(Object.keys(this.keys).indexOf(key) != -1) {\n      oldSerializedValue = this.keys[key];\n    }\n    if (value === oldSerializedValue)\n      return;\n\n    this.keys[key] = value;\n\n    Data.notify('change');\n  }\n  setDefault(key, value) {\n    // for now, explicitly check for undefined, since there is no\n    // ReactiveDict.clear().  Later we might have a ReactiveDict.clear(), in which case\n    // we should check if it has the key.\n    if (this.keys[key] === undefined) {\n      this.set(key, value);\n    }\n  }\n  get(key) {\n    return parse(this.keys[key]);\n  }\n  equals(key, value) {\n    // We don't allow objects (or arrays that might include objects) for\n    // .equals, because JSON.stringify doesn't canonicalize object key\n    // order. (We can make equals have the right return value by parsing the\n    // current value and using EJSON.equals, but we won't have a canonical\n    // element of keyValueDeps[key] to store the dependency.) You can still use\n    // \"EJSON.equals(reactiveDict.get(key), value)\".\n    //\n    // XXX we could allow arrays as long as we recursively check that there\n    // are no objects\n    if (typeof value !== 'string' &&\n        typeof value !== 'number' &&\n        typeof value !== 'boolean' &&\n        typeof value !== 'undefined' &&\n        !(value instanceof Date) &&\n        !(ObjectID && value instanceof ObjectID) &&\n        value !== null)\n      throw new Error(\"ReactiveDict.equals: value must be scalar\");\n\n    const serializedValue = stringify(value);\n\n    let oldValue = undefined;\n    if(Object.keys(this.keys).indexOf(key) != -1) {\n      oldValue = parse(this.keys[key])\n    }\n    return EJSON.equals(oldValue, value);\n  }\n  _setObject(object) {\n\n    const keys = Object.keys(object);\n\n    for(let i in keys) {\n      this.set(i, keys[i]);\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-meteor/node_modules/react-native-meteor/src/CollectionFS/FSCollectionImagesPreloader.js":"'use strict';\n\nimport React, { Component, PropTypes } from 'react';\nimport { View, Image, StyleSheet } from 'react-native';\n\n\nimport Data from '../Data';\nimport setProperties from './setProperties';\n\nexport default class FSCollectionImagesPreloader extends Component {\n  static propTypes = {\n    collection: PropTypes.string.isRequired,\n    selector: PropTypes.oneOfType([ PropTypes.string, PropTypes.object ])\n  };\n  static defaultProps = {\n    selector: {}\n  };\n  constructor(props) {\n    super(props);\n    this.state = {\n      items: []\n    };\n  }\n  componentWillMount() {\n    const { collection, selector } = this.props;\n\n\n    this.update = results=>{\n      this.setState({\n        items: results.map(elem=>setProperties(collection, elem))\n      });\n    };\n\n    const collectionName = 'cfs.'+collection+'.filerecord';\n\n    if(!Data.db[collectionName]) {\n      Data.db.addCollection(collectionName)\n    }\n\n    this.items = Data.db.observe(() => {\n      return Data.db[collectionName].find(selector);\n    });\n\n    this.items.subscribe(this.update);\n  }\n  componentWillUnmount() {\n    this.items.dispose();\n  }\n  render() {\n    const { items } = this.state;\n\n    return (\n      <View style={styles.hidden}>\n        {items && items.map(item=>{\n          return (\n            <Image style={styles.hidden} key={item._id} source={{uri: item.url()}} />\n          );\n        })}\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  hidden: {\n    width: 1,\n    height: 1,\n    position: 'absolute',\n    top: -100000,\n    left: -10000,\n    opacity: 0\n  }\n})","/home/travis/build/npmtest/node-npmtest-react-native-meteor/node_modules/react-native-meteor/src/CollectionFS/FSCollection.js":"import EJSON from \"ejson\";\n\nimport Collection from '../Collection';\nimport Data from '../Data';\nimport setProperties from './setProperties';\n\n\nif(!EJSON._getTypes()['FS.File']) {\n  EJSON.addType('FS.File', function(value) {\n    return {\n      getFileRecord() {\n        const collection = Data.db['cfs.'+value.collectionName+'.filerecord'];\n\n        const item = collection && collection.get(value._id);\n\n        if(!item) return value;\n\n        return setProperties(value.collectionName, item);\n      }\n    };\n  }); \n}\n\nexport default function(name) {\n  const Meteor = this;\n  const collectionName = 'cfs.'+name+'.filerecord';\n\n\n  return {\n    find(selector, options) {\n      const elems = Collection(collectionName).find(selector, options);\n      return elems.map(elem=>{\n        return setProperties(name, elem);\n      });\n    },\n    findOne(selector, options) {\n      const elem = Collection(collectionName).findOne(selector, options);\n      return elem && setProperties(name, elem);\n    },\n    insert: function() { Collection.apply(Meteor, [collectionName]).insert.apply(Meteor, arguments); },\n    update: function() { Collection.apply(Meteor, [collectionName]).update.apply(Meteor, arguments); },\n    remove: function() { Collection.apply(Meteor, [collectionName]).remove.apply(Meteor, arguments); },\n  };\n}\n\n\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-react-native-meteor/node_modules/react-native-meteor/src/CollectionFS/setProperties.js":"\nimport base64 from 'base-64';\nimport Data from '../Data';\n\nexport default (name, file)=> {\n  const getStoreName = (params = {store: name}) => {\n    return params.store;\n  };\n  const getImageInfos = params => {\n    if(!params || !params.store) return file.original || {};\n    return file.copies[params.store] || {};\n  };\n  const getType = params => {\n    return getImageInfos(params).type;\n  };\n  return {\n    ...file,\n    url: params => {\n      const token = Data._tokenIdSaved;\n      const fileName = getImageInfos(params).name;\n      return Data.getUrl().replace('ws://', 'http://').replace('wss://', 'https://')+'/cfs/files/'+name+'/'+file._id+'/'+fileName+'?store='+getStoreName(params)+(token ? '&token='+base64.encode(JSON.stringify({authToken: token})) : \"\");\n    },\n    isImage: params => {\n      const type = getType(params);\n      return type && type.indexOf('image/')===0;\n    },\n    isAudio: params => {\n      const type = getType(params);\n      return type && type.indexOf('audio/')===0;\n    },\n    isVideo: params => {\n      const type = getType(params);\n      return type && type.indexOf('video/')===0;\n    },\n    isUploaded: params => {\n      return !!(getImageInfos(params).updatedAt);\n    },\n    name: params => {\n      return getImageInfos(params).name;\n    },\n    extension: params => {\n      const imageName = getImageInfos(params).name;\n      if(!imageName) return;\n      return imageName.substring(imageName.lastIndexOf('.')+1);\n    },\n    size: params => {\n      return getImageInfos(params).size;\n    },\n    type: getType,\n    updatedAt: params=>{\n      return getImageInfos(params).updatedAt;\n    }\n  }\n}","/home/travis/build/npmtest/node-npmtest-react-native-meteor/node_modules/react-native-meteor/src/components/ComplexListView.js":"'use strict';\n\nimport React, { Component, PropTypes } from 'react';\nimport { ListView } from 'react-native';\n\n\nimport Data from '../Data';\n\n\nexport default class MeteorListView extends Component {\n  static propTypes = {\n    elements: PropTypes.func.isRequired,\n    renderRow: PropTypes.func.isRequired,\n    listViewRef: PropTypes.oneOfType([ PropTypes.func, PropTypes.string ])\n  };\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      ds: new ListView.DataSource({\n        rowHasChanged: (row1, row2) => row1!==row2,\n      })\n    };\n  }\n  componentWillReceiveProps(props) {\n    const { elements } = props;\n\n    const elems = elements();\n    this.setState({\n      ds: this.state.ds.cloneWithRows(elems)\n    });\n\n  }\n  componentWillMount() {\n\n    const { elements } = this.props;\n\n    this.onChange = ()=>{\n      const elems = elements();\n      this.setState({\n        ds: this.state.ds.cloneWithRows(elems)\n      });\n    };\n\n    this.onChange();\n    Data.onChange(this.onChange);\n\n  }\n  componentWillUnmount() {\n    Data.offChange(this.onChange);\n  }\n  render() {\n    const { ds } = this.state;\n    const { listViewRef, ...props } = this.props;\n\n    return (\n      <ListView\n        {...props}\n        ref={listViewRef}\n        dataSource={ds}\n      />\n    );\n  }\n}","/home/travis/build/npmtest/node-npmtest-react-native-meteor/node_modules/react-native-meteor/src/components/composeWithTracker.js":"import Trackr from 'trackr';\nimport { compose } from 'react-komposer';\n\nimport Data from '../Data';\n\nexport default function(reactiveFn, L, E, options) {\n  const onPropsChange = (props, onData) => {\n    let trackerCleanup;\n\n    const _meteorDataDep = new Trackr.Dependency();\n    const _meteorDataChangedCallback = ()=>{_meteorDataDep.changed()};\n\n    Data.onChange(_meteorDataChangedCallback);\n\n    const handler = Trackr.nonreactive(() => {\n      return Trackr.autorun(() => {\n        _meteorDataDep.depend();\n        trackerCleanup = reactiveFn(props, onData);\n      });\n    });\n\n    return () => {\n      if (typeof (trackerCleanup) === 'function') {\n        trackerCleanup();\n      }\n      Data.offChange(_meteorDataChangedCallback);\n      return handler.stop();\n    };\n  };\n\n  return compose(onPropsChange, L, E, options);\n}","/home/travis/build/npmtest/node-npmtest-react-native-meteor/node_modules/react-native-meteor/src/components/createContainer.js":"/**\n * Container helper using react-meteor-data.\n */\n\nimport React from 'react';\n\nimport Mixin from './Mixin';\n\nexport default function createContainer(options = {}, Component) {\n  let expandedOptions = options;\n  if (typeof options === 'function') {\n    expandedOptions = {\n      getMeteorData: options,\n    };\n  }\n\n  const {\n    getMeteorData\n  } = expandedOptions;\n\n  return React.createClass({\n    displayName: 'MeteorDataContainer',\n    mixins: [Mixin],\n    getMeteorData() {\n      return getMeteorData(this.props);\n    },\n    render() {\n      return <Component {...this.props} {...this.data} />;\n    },\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-meteor/node_modules/react-native-meteor/src/components/ListView.js":"'use strict';\n\nimport React, { Component, PropTypes } from 'react';\nimport { ListView } from 'react-native';\n\nimport Data from '../Data';\n\n\nexport default class MeteorListView extends Component {\n  static propTypes = {\n    collection: PropTypes.string.isRequired,\n    selector: PropTypes.oneOfType([ PropTypes.string, PropTypes.object ]),\n    options: PropTypes.oneOfType([ PropTypes.string, PropTypes.object ]),\n    renderRow: PropTypes.func.isRequired,\n    listViewRef: PropTypes.oneOfType([ PropTypes.func, PropTypes.string ])\n  };\n  static defaultProps = {\n    selector: {}\n  };\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      ds: new ListView.DataSource({\n        rowHasChanged: (row1, row2) => row1!==row2,\n      })\n    };\n  }\n  componentWillReceiveProps(props) {\n    const { collection, selector, options } = props;\n\n    this.update(Data.db[collection].find(selector, options));\n  }\n  componentWillMount() {\n    const { collection, selector, options } = this.props;\n\n\n    this.update = results=>{\n      this.setState({\n        ds: this.state.ds.cloneWithRows(results)\n      });\n    };\n\n\n    if(!Data.db[collection]) {\n      Data.db.addCollection(collection)\n    }\n\n    this.items = Data.db.observe(() => {\n      return Data.db[collection].find(selector, options);\n    });\n\n    this.items.subscribe(this.update);\n  }\n  componentWillUnmount() {\n    this.items.dispose();\n  }\n  render() {\n    const { ds } = this.state;\n    const { listViewRef, ...props } = this.props;\n\n    return (\n      <ListView\n        {...props}\n        ref={listViewRef}\n        dataSource={ds}\n      />\n    );\n  }\n}","/home/travis/build/npmtest/node-npmtest-react-native-meteor/node_modules/react-native-meteor/src/components/Mixin.js":"import Trackr from 'trackr';\nimport EJSON from 'ejson';\nimport Data from '../Data';\n\nexport default {\n  componentWillMount() {\n\n    Data.waitDdpReady(()=>{\n      if(this.getMeteorData) {\n        this.data = {};\n        this._meteorDataManager = new MeteorDataManager(this);\n        const newData = this._meteorDataManager.calculateData();\n        this._meteorDataManager.updateData(newData);\n      }\n    });\n\n\n  },\n  componentWillUpdate(nextProps, nextState) {\n\n    if(this.startMeteorSubscriptions) {\n      if(!EJSON.equals(this.state, nextState) || !EJSON.equals(this.props, nextProps)) {\n        this._meteorSubscriptionsManager._meteorDataChangedCallback()\n      }\n    }\n\n    if(this.getMeteorData) {\n      const saveProps = this.props;\n      const saveState = this.state;\n      let newData;\n      try {\n        // Temporarily assign this.state and this.props,\n        // so that they are seen by getMeteorData!\n        // This is a simulation of how the proposed Observe API\n        // for React will work, which calls observe() after\n        // componentWillUpdate and after props and state are\n        // updated, but before render() is called.\n        // See https://github.com/facebook/react/issues/3398.\n        this.props = nextProps;\n        this.state = nextState;\n        newData = this._meteorDataManager.calculateData();\n      } finally {\n        this.props = saveProps;\n        this.state = saveState;\n      }\n\n      this._meteorDataManager.updateData(newData);\n    }\n\n  },\n  componentWillUnmount() {\n    if(this._meteorDataManager) {\n      this._meteorDataManager.dispose();\n    }\n\n    if(this._meteorSubscriptionsManager) {\n      this._meteorSubscriptionsManager.dispose();\n    }\n\n  }\n};\n\n\n// A class to keep the state and utility methods needed to manage\n// the Meteor data for a component.\nclass MeteorDataManager {\n  constructor(component) {\n    this.component = component;\n    this.computation = null;\n    this.oldData = null;\n    this._meteorDataDep = new Trackr.Dependency();\n\n    this._meteorDataChangedCallback = ()=>{this._meteorDataDep.changed()};\n\n    Data.onChange(this._meteorDataChangedCallback);\n  }\n\n  dispose() {\n    if (this.computation) {\n      this.computation.stop();\n      this.computation = null;\n    }\n\n    Data.offChange(this._meteorDataChangedCallback);\n  }\n\n  calculateData() {\n    const component = this.component;\n\n    if (!component.getMeteorData) {\n      return null;\n    }\n\n    if (this.computation) {\n      this.computation.stop();\n      this.computation = null;\n    }\n\n    let data;\n    // Use Tracker.nonreactive in case we are inside a Tracker Computation.\n    // This can happen if someone calls `ReactDOM.render` inside a Computation.\n    // In that case, we want to opt out of the normal behavior of nested\n    // Computations, where if the outer one is invalidated or stopped,\n    // it stops the inner one.\n\n    this.computation = Trackr.nonreactive(() => {\n      return Trackr.autorun((c) => {\n        this._meteorDataDep.depend();\n        if (c.firstRun) {\n          const savedSetState = component.setState;\n          try {\n            component.setState = () => {\n              throw new Error(\n\"Can't call `setState` inside `getMeteorData` as this could cause an endless\" +\n\" loop. To respond to Meteor data changing, consider making this component\" +\n\" a \\\"wrapper component\\\" that only fetches data and passes it in as props to\" +\n\" a child component. Then you can use `componentWillReceiveProps` in that\" +\n\" child component.\");\n            };\n\n            data = component.getMeteorData();\n          } finally {\n            component.setState = savedSetState;\n          }\n\n\n        } else {\n          // Stop this computation instead of using the re-run.\n          // We use a brand-new autorun for each call to getMeteorData\n          // to capture dependencies on any reactive data sources that\n          // are accessed.  The reason we can't use a single autorun\n          // for the lifetime of the component is that Tracker only\n          // re-runs autoruns at flush time, while we need to be able to\n          // re-call getMeteorData synchronously whenever we want, e.g.\n          // from componentWillUpdate.\n          c.stop();\n          // Calling forceUpdate() triggers componentWillUpdate which\n          // recalculates getMeteorData() and re-renders the component.\n          try {\n            component.forceUpdate();\n          } catch(e) {\n            console.error(e);\n          }\n\n        }\n      });\n    });\n\n    return data;\n  }\n\n  updateData(newData) {\n    const component = this.component;\n    const oldData = this.oldData;\n\n    if (! (newData && (typeof newData) === 'object')) {\n      throw new Error(\"Expected object returned from getMeteorData\");\n    }\n    // update componentData in place based on newData\n    for (let key in newData) {\n      component.data[key] = newData[key];\n    }\n    // if there is oldData (which is every time this method is called\n    // except the first), delete keys in newData that aren't in\n    // oldData.  don't interfere with other keys, in case we are\n    // co-existing with something else that writes to a component's\n    // this.data.\n    if (oldData) {\n      for (let key in oldData) {\n        if (!(key in newData)) {\n          delete component.data[key];\n        }\n      }\n    }\n    this.oldData = newData;\n  }\n}\n\n","/home/travis/build/npmtest/node-npmtest-react-native-meteor/node_modules/react-native-meteor/src/user/Accounts.js":"import Data from '../Data';\nimport call from '../Call';\nimport User from './User';\nimport { hashPassword } from '../../lib/utils';\n\n\nmodule.exports = {\n  createUser(options, callback = ()=>{}) {\n    if (options.username) options.username = options.username;\n    if (options.email) options.email = options.email;\n\n    // Replace password with the hashed password.\n    options.password = hashPassword(options.password);\n\n    User._startLoggingIn();\n    call(\"createUser\", options, (err, result)=>{\n      User._endLoggingIn();\n\n      User._handleLoginCallback(err, result);\n\n      callback(err);\n    });\n  },\n  changePassword(oldPassword, newPassword, callback = ()=>{}) {\n\n    //TODO check Meteor.user() to prevent if not logged\n\n    if(typeof newPassword != 'string' || !newPassword) {\n      return callback(\"Password may not be empty\");\n    }\n\n    call(\"changePassword\",\n          oldPassword ? hashPassword(oldPassword) : null,\n          hashPassword(newPassword),\n      (err, res) => {\n\n      callback(err);\n    });\n  },\n  forgotPassword(options, callback = ()=>{}) {\n    if (!options.email) {\n      return callback(\"Must pass options.email\");\n    }\n\n    call(\"forgotPassword\", options, err => {\n      callback(err);\n    });\n  },\n  resetPassword(token, newPassword, callback = ()=>{}) {\n    if (!newPassword) {\n      return callback(\"Must pass a new password\");\n    }\n\n    call(\"resetPassword\", token, hashPassword(newPassword), (err, result) => {\n      if (!err) {\n        User._loginWithToken(result.token);\n      }\n\n      callback(err);\n    });\n  },\n  onLogin(cb) {\n    Data.on('onLogin', cb);\n  },\n  onLoginFailure(cb) {\n    Data.on('onLoginFailure', cb);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-meteor/node_modules/react-native-meteor/src/user/User.js":"import { AsyncStorage } from 'react-native';\n\nimport Data from '../Data';\nimport { hashPassword } from '../../lib/utils';\nimport call from '../Call';\n\nconst TOKEN_KEY = 'reactnativemeteor_usertoken';\n\nmodule.exports = {\n  user() {\n    if(!this._userIdSaved) return null;\n\n    return this.collection('users').findOne(this._userIdSaved);\n  },\n  userId() {\n    if(!this._userIdSaved) return null;\n\n    const user = this.collection('users').findOne(this._userIdSaved);\n    return user && user._id;\n  },\n  _isLoggingIn: true,\n  loggingIn() {\n    return this._isLoggingIn;\n  },\n  logout(callback) {\n    call(\"logout\", err => {\n      this.handleLogout();\n      this.connect();\n\n      typeof callback == 'function' && callback(err);\n    });\n  },\n  handleLogout() {\n    AsyncStorage.removeItem(TOKEN_KEY);\n    Data._tokenIdSaved = null;\n    this._userIdSaved = null;\n  },\n  loginWithPassword(selector, password, callback) {\n    if (typeof selector === 'string') {\n      if (selector.indexOf('@') === -1)\n        selector = {username: selector};\n      else\n        selector = {email: selector};\n    }\n\n    this._startLoggingIn();\n    call(\"login\", {\n        user: selector,\n        password: hashPassword(password)\n    }, (err, result)=>{\n      this._endLoggingIn();\n\n      this._handleLoginCallback(err, result);\n\n      typeof callback == 'function' && callback(err);\n    });\n  },\n  logoutOtherClients(callback = ()=>{}) {\n    call('getNewToken', (err, res) => {\n      if(err) return callback(err);\n\n      this._handleLoginCallback(err, res);\n\n      call('removeOtherTokens', err=>{\n        callback(err);\n      })\n    });\n  },\n  _login(user, callback) {\n    this._startLoggingIn();\n    this.call(\"login\", user, (err, result)=>{\n      this._endLoggingIn();\n\n      this._handleLoginCallback(err, result);\n\n      typeof callback == 'function' && callback(err);\n    });\n  },\n  _startLoggingIn() {\n    this._isLoggingIn = true;\n    Data.notify('loggingIn');\n  },\n  _endLoggingIn() {\n    this._isLoggingIn = false;\n    Data.notify('loggingIn');\n  },\n  _handleLoginCallback(err, result) {\n    if(!err) {//save user id and token\n      AsyncStorage.setItem(TOKEN_KEY, result.token);\n      Data._tokenIdSaved = result.token;\n      this._userIdSaved = result.id;\n      Data.notify('onLogin');\n    } else {\n      Data.notify('onLoginFailure');\n      this.handleLogout();\n    }\n    Data.notify('change');\n  },\n  _loginWithToken(value) {\n    Data._tokenIdSaved = value;\n    if (value !== null){\n      this._startLoggingIn();\n      call('login', { resume: value }, (err, result) => {\n        this._endLoggingIn();\n        this._handleLoginCallback(err, result);\n      });\n    } else {\n      this._endLoggingIn();\n    }\n  },\n  getAuthToken() {\n    return Data._tokenIdSaved;\n  },\n  async _loadInitialUser() {\n    var value = null;\n    try {\n      value = await AsyncStorage.getItem(TOKEN_KEY);\n    } catch (error) {\n      console.warn('AsyncStorage error: ' + error.message);\n    } finally {\n      this._loginWithToken(value);\n    }\n\n  }\n}\n"}